================================================================================
SLATEHUB PROJECT CONTEXT - AI ASSISTANT PROMPT
================================================================================

You are working on SlateHub, a production-ready web application built with modern Rust technologies and strict architectural principles. This document provides the complete technical context you need to understand and contribute to the project.

================================================================================
PROJECT OVERVIEW
================================================================================

SlateHub is a free, open-source SaaS platform for the TV, film, and content industries. It combines professional networking (like LinkedIn) with project management capabilities (like GitHub), specifically tailored for creative professionals.

================================================================================
TECHNICAL STACK
================================================================================

BACKEND TECHNOLOGY:
- Language: Rust (Edition 2024)
- Web Framework: Axum 0.8.4 (async web framework)
- Database: SurrealDB 2.3.7 (multi-model database)
- Object Storage: MinIO/AWS S3 (via aws-sdk-s3)
- Template Engine: Askama 0.12 (compile-time checked templates)
- Authentication: JWT (jsonwebtoken), Argon2 password hashing
- Async Runtime: Tokio (full features)

ARCHITECTURE PATTERN:
- MVC (Model-View-Controller) with strict separation
- Server-Side Rendering (SSR) only - NO client-side frameworks
- Models handle ALL database interactions exclusively
- Controllers (routes) orchestrate between models and views
- Views are Askama templates that generate HTML

PROJECT STRUCTURE:
```
slatehub/
├── server/
│   ├── src/
│   │   ├── models/        # Database models (ONLY place for DB access)
│   │   ├── routes/        # HTTP route handlers (controllers)
│   │   │   ├── api.rs             # API endpoints
│   │   │   ├── auth.rs            # Authentication routes (login, signup, logout)
│   │   │   ├── equipment.rs       # Equipment management routes
│   │   │   ├── locations.rs       # Location management routes
│   │   │   ├── media.rs           # Media upload/management routes
│   │   │   ├── organizations.rs   # Organization management routes
│   │   │   ├── pages.rs           # Static pages (/, /about, /terms, /privacy)
│   │   │   ├── productions.rs     # Production management routes
│   │   │   ├── profile.rs         # User profile management routes
│   │   │   └── public_profiles.rs # Public profile views (/people, /{username})
│   │   ├── services/      # Business logic and external services
│   │   ├── middleware/    # Request/response middleware
│   │   ├── templates/     # Askama HTML templates (views)
│   │   ├── main.rs        # Application entry point
│   │   ├── auth.rs        # Authentication logic
│   │   ├── db.rs          # Database connection management
│   │   ├── config.rs      # Configuration management
│   │   └── error.rs       # Error handling
│   ├── static/            # Static assets (CSS, images)
│   └── Cargo.toml         # Rust dependencies
├── db/
│   └── schema.surql       # Complete database schema and seed data
├── docs/                  # Documentation
└── docker-compose.yml     # Local development environment
```

================================================================================
CRITICAL ARCHITECTURAL PRINCIPLES
================================================================================

1. STRICT MVC SEPARATION:
   - Models: ONLY access the database, NO business logic
   - Controllers (Routes): Handle HTTP requests, call models and services
   - Views (Templates): Render HTML, NO logic beyond display

2. DATABASE ACCESS RULES:
   - ONLY models can interact with SurrealDB
   - Routes/controllers MUST use models for ALL database operations
   - Services can call models but NEVER access DB directly
   - Use SurrealDB's query builder, NOT raw SQL

3. SERVER-SIDE RENDERING ONLY:
   - ALL HTML is generated server-side using Askama templates
   - NO React, Vue, Angular, or any client-side framework
   - NO client-side state management libraries
   - NO build tools for JavaScript (no webpack, no bundlers)
   - NO datastar.js or similar reactive libraries
   - NO Server-Sent Events (SSE) or WebSockets for UI updates
   - JavaScript is minimal and only for progressive enhancement
   - Forms submit via standard HTTP POST, not AJAX

4. STRICT SEPARATION OF CONCERNS (NON-NEGOTIABLE):
   HTML, CSS, and JavaScript must be completely separated:

   HTML (Templates):
   - MUST contain ONLY semantic markup
   - MUST use semantic HTML5 elements (article, section, nav, header, footer, etc.)
   - MUST use data attributes for component identification and state
   - MUST use IDs for unique landmarks and form associations
   - MUST NOT contain ANY styling classes
   - MUST NOT contain inline styles
   - MUST NOT reference visual appearance in any way

   CSS (Stylesheets):
   - MUST use ONLY semantic selectors
   - MUST target elements by their semantic meaning, IDs, and data attributes
   - MUST use attribute selectors for state (e.g., [aria-expanded="true"])
   - MUST use pseudo-classes for interaction states (:hover, :focus, :active)
   - MUST live in separate CSS files under /static/css/
   - MUST NOT use CSS classes for styling

   JavaScript:
   - MUST be vanilla JavaScript (no frameworks)
   - MUST use semantic selectors to find elements
   - MUST manipulate state through data attributes and ARIA attributes
   - MUST NOT add or remove CSS classes for styling

5. TEMPLATE ENGINE (ASKAMA):
   - Templates are compiled at build time for type safety
   - Use template inheritance for consistent layouts
   - Templates live in server/src/templates/
   - Extension: .html (but they're Askama templates)

6. AUTHENTICATION & AUTHORIZATION:
   - JWT tokens for session management
   - Tokens stored in HTTP-only cookies
   - Argon2 for password hashing
   - Middleware handles auth checks

7. FILE STORAGE:
   - MinIO (S3-compatible) for object storage
   - Images, documents stored in MinIO buckets
   - Database stores only file metadata and URLs

================================================================================
HTML STRUCTURE & NAMING CONVENTIONS
================================================================================

ID NAMING CONVENTIONS:
IDs should be used for:
1. Page landmarks - Major sections of the page
2. Form associations - Linking labels to inputs and error messages
3. Navigation targets - Anchor links and skip navigation
4. Unique interactive elements - Elements that need JavaScript interaction

ID Naming Pattern: [context]-[element]-[purpose]

Examples:
- #main-nav - Main navigation
- #user-menu - User account menu
- #profile-header - Profile page header
- #form-login - Login form
- #input-email - Email input field
- #error-email - Email error message
- #section-experience - Experience section
- #heading-skills - Skills section heading

DATA ATTRIBUTE CONVENTIONS:

Component Identification:
Use data-component for major reusable components:
- <article data-component="profile-card" data-user-id="123">
- <section data-component="media-gallery">
- <nav data-component="breadcrumb">

Page/Section Context:
Use data-page and data-section for page-specific styling:
- <body data-page="profile">
- <main data-section="user-content">
- <article data-section="project-details">

State Management:
Use data-state for element states:
- <article data-state="published">
- <button data-state="loading">
- <form data-state="submitting">
- <div data-state="empty">

Feature Flags:
Use specific data attributes for features:
- <article data-featured="true">
- <section data-editable="true">
- <div data-collapsible="true" data-collapsed="false">

Content Type:
Use data-type for content variations:
- <article data-type="blog-post">
- <article data-type="project">
- <button data-type="primary">
- <button data-type="danger">

Role/Purpose:
Use data-role for semantic purposes (when ARIA roles aren't appropriate):
- <div data-role="thumbnail">
- <span data-role="badge">
- <div data-role="overlay">

================================================================================
DATABASE SCHEMA PATTERNS
================================================================================

SURREALDB CONVENTIONS:
- **SCHEMAFUL TABLES**: Always define tables with SCHEMAFULL mode
- **NO MIGRATIONS**: Update schema.surql file directly instead of using migration files
- **SEED DATA IN SCHEMA**: Include all lists, lookups, and internal data in schema.surql
- Use ULID for record IDs
- Relationships via RELATE statements
- **PREFER GRAPH RELATIONS**: Use SurrealDB's graph capabilities whenever relationships make sense
  - Use RELATE for many-to-many relationships
  - Leverage graph traversal for connected data queries
  - Model relationships as first-class entities when they have properties
  - Examples: user->FOLLOWS->user, user->MEMBER_OF->organization, project->USES->skill
- Define schemas with DEFINE statements

SCHEMA MANAGEMENT:
- All table definitions in db/schema.surql
- Direct updates to schema.surql (no migration files)
- Include seed data for:
  - Lookup tables (countries, languages, skills, etc.)
  - System roles and permissions
  - Default categories and tags
  - Any static reference data

EXAMPLE SCHEMA (db/schema.surql):
```sql
-- Define schemaful table
DEFINE TABLE person SCHEMAFULL;
DEFINE FIELD username ON TABLE person TYPE string ASSERT $value != NONE;
DEFINE FIELD email ON TABLE person TYPE string ASSERT string::is::email($value);
DEFINE FIELD created_at ON TABLE person TYPE datetime DEFAULT time::now();
DEFINE INDEX person_email ON TABLE person COLUMNS email UNIQUE;

-- Define relationship tables
DEFINE TABLE follows SCHEMAFULL;
DEFINE FIELD in ON TABLE follows TYPE record<person>;
DEFINE FIELD out ON TABLE follows TYPE record<person>;
DEFINE FIELD created_at ON TABLE follows TYPE datetime DEFAULT time::now();

-- Insert reference data directly
INSERT INTO skill [
    { id: skill:rust, name: "Rust", category: "Programming" },
    { id: skill:typescript, name: "TypeScript", category: "Programming" },
    { id: skill:editing, name: "Video Editing", category: "Post-Production" }
];

INSERT INTO role [
    { id: role:admin, name: "Administrator", permissions: ["*"] },
    { id: role:member, name: "Member", permissions: ["read", "write:own"] }
];
```

EXAMPLE MODEL:
```rust
// Always use SurrealDB's typed queries
let person: Option<Person> = db
    .select(("person", person_id))
    .await?;

// For complex queries
let results = db
    .query("SELECT * FROM person WHERE email = $email")
    .bind(("email", email))
    .await?;

// PREFER GRAPH RELATIONS for connected data
let connections = db
    .query("SELECT ->follows->person FROM person:$person_id")
    .bind(("person_id", person_id))
    .await?;

// Create relationships
let _ = db
    .query("RELATE $person->follows->$target")
    .bind(("person", person_id))
    .bind(("target", target_id))
    .await?;
```

================================================================================
ID HANDLING POLICY
================================================================================

CORE PRINCIPLE:
**ALWAYS use full record IDs internally. ONLY strip table prefixes for URLs.**

SurrealDB uses record IDs in the format `table:id` (e.g., `person:3t5kimq47s30s2nq0t3g`, `organization:5dfvs3jphb2axku0dpu2`). This policy ensures consistent ID handling throughout the codebase.

THE GOLDEN RULE:

✅ INTERNAL = FULL ID
- Database queries: Use full IDs directly
- Session/JWT tokens: Store full IDs
- Function parameters: Pass full IDs
- Data structures: Store full IDs
- API responses: Return full IDs
- Logging: Log full IDs

🔗 URLS = ID WITHOUT TABLE PREFIX
- Route paths: `/productions/3t5kimq47s30s2nq0t3g` (not `/productions/production:3t5kimq47s30s2nq0t3g`)
- Query parameters: `?id=3t5kimq47s30s2nq0t3g`
- Path parameters: `/orgs/5dfvs3jphb2axku0dpu2/edit`
- Profile paths: `/{username}` (usernames are used for public profiles, not IDs)

IMPLEMENTATION GUIDELINES:

Database Queries - CORRECT:
```rust
// When you have a full ID, use it directly
let query = "SELECT * FROM organization_members WHERE out = $user_id";
DB.query(query).bind(("user_id", "person:3t5kimq47s30s2nq0t3g"))

// For relationships
let query = "RELATE $org->organization_members->$person SET role = $role";
DB.query(query)
    .bind(("org", "organization:5dfvs3jphb2axku0dpu2"))
    .bind(("person", "person:3t5kimq47s30s2nq0t3g"))
```

Database Queries - INCORRECT:
```rust
// DON'T do this if you already have a full ID
let query = "WHERE out = type::thing('person', $user_id)";  // WRONG!

// DON'T strip prefixes for queries
let clean_id = user_id.strip_prefix("person:");  // WRONG!
```

Session and Authentication:
```rust
// SessionUser should store the full ID
pub struct SessionUser {
    pub id: String,  // Full ID like "person:3t5kimq47s30s2nq0t3g"
    pub username: String,
    pub email: String,
}
```

Route Handlers:
```rust
// Route receives slug/username (no prefix in URL)
async fn user_profile(Path(username): Path<String>) -> Result<Html<String>, Error> {
    let user = PersonModel::find_by_username(&username).await?;
    // user.id is "person:3t5kimq47s30s2nq0t3g" - full ID

    // Pass full ID to other functions
    let organizations = OrgModel::get_user_organizations(&user.id).await?;
}
```

URL Generation in Templates:
```html
<!-- Use slug for organization URLs -->
<a href="/orgs/{{ organization.slug }}">View Organization</a>

<!-- For user profiles, use username directly -->
<a href="/{{ user.username }}">View Profile</a>

<!-- Never include the table prefix in URLs -->
<!-- WRONG: <a href="/orgs/organization:{{ org.id }}"> -->
```

File Storage Exception (S3/MinIO):
```rust
// Strip prefix for S3 paths to avoid colons in keys
let sanitized_id = user.id.strip_prefix("person:").unwrap_or(&user.id);
let key = format!("profiles/{}/avatar.jpg", sanitized_id);
```

DEBUGGING ID ISSUES:

Common Symptoms:
- Empty query results when data exists: Check for double-prefixing (e.g., `person:person:xyz`)
- "Record not found" errors: Verify full ID format matches database records
- Relationship creation failures: Ensure both sides use full IDs

Debug Logging:
```rust
debug!("Fetching organizations for user ID: '{}'", user_id);
debug!("Creating relationship: {} -> {} with role: {}", org_id, person_id, role);
```

KEY POINTS:
- Internal Operations: Always use full IDs (`table:id`)
- URLs Only: Strip table prefix for cleaner URLs
- No Ambiguity: Functions should know if they expect full IDs
- Be Explicit: Document parameter expectations
- Log Clearly: Always log exact ID format being used

================================================================================
SEMANTIC HTML STRUCTURE PATTERNS
================================================================================

PROPER ELEMENT USAGE:

Article Element (<article>):
- Use ONLY for self-contained, independently distributable content
- Good for: Blog posts, news articles, project cards, user comments
- NOT for: Forms, page sections, navigation, footers, UI components

Section Element (<section>):
- Use for thematic grouping of content with a heading
- Good for: Page regions, form wrappers, content groups
- Always include a heading (h1-h6) or aria-label

Div Element (<div>):
- Use for generic containers with no semantic meaning
- Good for: Layout wrappers, styling hooks, JavaScript targets
- Use when article/section aren't semantically appropriate

PAGE LAYOUT STRUCTURE:
```html
<body data-page="[page-name]" data-user="[authenticated|anonymous]">
    <header id="site-header">
        <nav id="main-nav" aria-label="Main navigation">
            <!-- Logo/Brand -->
            <div data-role="brand">
                <a href="/" id="site-logo">SlateHub</a>
            </div>

            <!-- Primary Navigation -->
            <ul data-role="nav-primary">
                <li><a href="/projects" aria-current="page">Projects</a></li>
                <li><a href="/people">People</a></li>
            </ul>

            <!-- User Navigation -->
            <ul data-role="nav-user">
                <li data-component="theme-toggle">
                    <button id="theme-toggle" aria-label="Toggle theme">
                        <span data-theme-icon="light">☀️</span>
                        <span data-theme-icon="dark">🌙</span>
                    </button>
                </li>
                <li data-component="user-menu">
                    <details id="user-menu">
                        <summary>User Name</summary>
                        <ul data-role="dropdown-menu">
                            <li><a href="/profile">Profile</a></li>
                            <li><a href="/logout">Logout</a></li>
                        </ul>
                    </details>
                </li>
            </ul>
        </nav>
    </header>

    <main id="main-content">
        <!-- Page-specific content -->
    </main>

    <footer id="site-footer">
        <section data-role="footer-main">
            <div data-role="footer-brand">
                <h3>Brand Name</h3>
                <p>Description</p>
            </div>
            <div data-role="footer-links">
                <h4>Links</h4>
                <nav><!-- links --></nav>
            </div>
        </section>
    </footer>
</body>
```

FORM STRUCTURE:
```html
<section id="section-[form-name]" data-component="auth-form" data-type="[login|signup|etc]">
    <header data-role="form-header">
        <h2 id="heading-[form]">Form Title</h2>
        <p>Form description</p>
    </header>

    <form id="form-[name]" data-component="form" method="post" action="/[endpoint]">
        <fieldset data-role="form-section">
            <legend>Section Title</legend>

            <div data-field="email">
                <label for="input-email">Email</label>
                <input
                    type="email"
                    id="input-email"
                    name="email"
                    required
                    aria-invalid="false"
                    aria-describedby="help-email error-email"
                >
                <small id="help-email" data-role="help-text">
                    Enter your email address
                </small>
                <div id="error-email" role="alert" data-role="error-message" hidden>
                    <!-- Error message -->
                </div>
            </div>
        </fieldset>

        <div data-role="form-actions">
            <button type="submit" data-type="primary">Submit</button>
            <button type="button" data-type="secondary">Cancel</button>
        </div>
    </form>
</section>
```

CONTENT CARD STRUCTURE:
```html
<!-- Use article ONLY for self-contained, redistributable content -->
<article data-component="content-card" data-type="[project|post|news]" data-id="[id]">
    <header data-role="card-header">
        <h3 id="card-title-[id]">Title</h3>
        <div data-role="metadata">
            <time datetime="2024-01-01">January 1, 2024</time>
            <span data-role="author">Author Name</span>
        </div>
    </header>

    <div data-role="card-body">
        <!-- Content -->
    </div>

    <footer data-role="card-footer">
        <nav data-role="card-actions">
            <button type="button" data-action="like">Like</button>
            <button type="button" data-action="share">Share</button>
        </nav>
    </footer>
</article>

<!-- For non-article content items like experience entries, use div -->
<div data-component="experience-item" data-id="[id]">
    <header data-role="item-header">
        <h3 id="item-title-[id]">Role Title</h3>
        <time>2024</time>
    </header>
    <div data-role="item-body">
        <!-- Description -->
    </div>
</div>
```

MODAL/DIALOG STRUCTURE:
```html
<dialog id="modal-[name]" data-component="modal" aria-labelledby="modal-title-[name]">
    <div data-role="modal-content">
        <header data-role="modal-header">
            <h2 id="modal-title-[name]">Modal Title</h2>
            <button type="button" data-action="close" aria-label="Close modal">×</button>
        </header>

        <div data-role="modal-body">
            <!-- Content -->
        </div>

        <footer data-role="modal-footer">
            <button type="button" data-type="primary">Confirm</button>
            <button type="button" data-type="secondary" data-action="cancel">Cancel</button>
        </footer>
    </div>
</dialog>
```

LIST/GRID STRUCTURE:
```html
<section data-component="content-list" data-layout="[grid|list]">
    <header data-role="section-header">
        <h2 id="heading-[section]">Section Title</h2>
        <nav data-role="filters">
            <button type="button" data-filter="all" aria-pressed="true">All</button>
            <button type="button" data-filter="recent" aria-pressed="false">Recent</button>
        </nav>
    </header>

    <div data-role="content-container" data-state="[loading|empty|error|ready]">
        <!-- When empty -->
        <div data-role="empty-state" data-state="empty">
            <p>No items found</p>
        </div>

        <!-- When has content -->
        <ul data-role="item-list">
            <li data-item="true" data-item-id="[id]">
                <!-- Item content -->
            </li>
        </ul>
    </div>

    <footer data-role="section-footer">
        <nav data-role="pagination" aria-label="Pagination">
            <a href="?page=1" aria-current="page">1</a>
            <a href="?page=2">2</a>
        </nav>
    </footer>
</section>
```

================================================================================
CSS SELECTOR PATTERNS
================================================================================

BASIC ELEMENT SELECTORS:
```css
/* Page-specific styling */
[data-page="profile"] main { }
[data-page="projects"] [data-section="filters"] { }

/* Component styling */
[data-component="content-card"] { }
[data-component="content-card"][data-type="featured"] { }

/* State-based styling */
[data-state="loading"] { }
[data-state="error"] { }
form[data-state="submitting"] button[type="submit"] { }

/* Navigation states */
nav a[aria-current="page"] { }
button[aria-pressed="true"] { }
details[open] > summary { }

/* Form states */
input[aria-invalid="true"] { }
input:required:valid { }
[data-role="error-message"]:not([hidden]) { }

/* Layout variations */
[data-layout="grid"] { }
[data-layout="list"] { }

/* Responsive containers */
[data-component="content-list"][data-layout="grid"] {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
}
```

CSS ORGANIZATION:
```
/static/css/
├── base/              # Base styles (currently empty, styles in main.css)
├── components/        # Component-specific styles (currently empty)
├── pages/            # Page-specific styles (currently empty)
├── main.css          # Complete design system and all styles
└── legal.css         # Legal pages extension for terms/privacy
```

Note: The project uses a consolidated approach with most styles in main.css rather than split files. The directory structure exists for future expansion if needed.

================================================================================
CODING STANDARDS & CONVENTIONS
================================================================================

RUST CONVENTIONS:
- Use async/await for all I/O operations
- Handle errors with Result types and thiserror
- Use tracing for logging (not println!)
- Follow Rust naming conventions (snake_case for functions/variables)

MODEL STRUCTURE:
```rust
// Models are data structs with static methods for database operations
use surrealdb::RecordId;
use crate::db::DB;  // Global database instance

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Person {
    pub id: RecordId,
    pub username: String,
    pub email: String,
    pub profile: Option<Profile>,
}

impl Person {
    // Static methods that use the global DB instance
    pub async fn get(id: &RecordId) -> Result<Option<Self>> {
        match DB.select(id).await {
            Ok(person) => Ok(person),
            Err(e) => Err(e.into())
        }
    }

    pub async fn find_by_username(username: &str) -> Result<Option<Self>> {
        let mut result = DB
            .query("SELECT * FROM person WHERE username = $username")
            .bind(("username", username))
            .await?;

        let person: Option<Person> = result.take(0)?;
        Ok(person)
    }
}
```

ROUTE STRUCTURE:
```rust
// routes orchestrate between models and templates
use crate::models::person::Person;
use crate::templates::PublicProfileTemplate;

pub async fn user_profile(
    Path(username): Path<String>,
    request: Request,
) -> Result<Html<String>, Error> {
    // Use static model methods directly
    let person = Person::find_by_username(&username).await?
        .ok_or(Error::NotFound)?;

    // Build and render template
    let template = PublicProfileTemplate {
        person,
        // ... other fields
    };

    let html = template.render()?;
    Ok(Html(html))
}
```

TEMPLATE STRUCTURE:
```html
{% extends "_layout.html" %}

{% block title %}
    Profile - {{ app_name }}
{% endblock %}

{% block page_name %}
    profile
{% endblock %}

{% block content %}
    <h1>{{ person.name }}</h1>
{% endblock %}
```

================================================================================
API DESIGN PATTERNS
================================================================================

KEY ROUTES:

PUBLIC PAGES:
- GET / - Homepage
- GET /people - Browse all profiles
- GET /{username} - View user's public profile
- GET /about - About page
- GET /terms - Terms of service
- GET /privacy - Privacy policy

AUTHENTICATION:
- GET /login - Login page
- POST /login - Process login
- GET /signup - Signup page
- POST /signup - Process signup
- POST /logout - Logout user

PROFILE MANAGEMENT (authenticated):
- GET /profile - View own profile
- GET /profile/edit - Edit profile form
- POST /profile - Update profile

PRODUCTIONS:
- GET /productions - List productions
- GET /productions/:id - View production
- GET /productions/new - Create form
- POST /productions - Create production
- GET /productions/:id/edit - Edit form
- POST /productions/:id - Update production
- DELETE /productions/:id - Delete production

ORGANIZATIONS:
- GET /orgs - List organizations
- GET /org/:slug - View organization
- GET /orgs/new - Create form
- POST /orgs - Create organization
- GET /org/:slug/edit - Edit form
- POST /org/:slug - Update organization

RESPONSE FORMATS:
- HTML for browser requests (via templates)
- JSON for API endpoints (when needed)
- Use proper HTTP status codes
- Consistent error responses

================================================================================
ERROR HANDLING
================================================================================

ERROR TYPES:
- Use thiserror for error definitions
- Convert errors at boundaries
- User-friendly error pages
- Log errors with tracing

PATTERN:
```rust
#[derive(thiserror::Error, Debug)]
pub enum AppError {
    #[error("User not found")]
    UserNotFound,

    #[error("Database error: {0}")]
    Database(#[from] surrealdb::Error),
}
```

================================================================================
DEVELOPMENT WORKFLOW
================================================================================

LOCAL SETUP:
1. docker-compose up (starts SurrealDB and MinIO)
2. cargo run (starts the web server)
3. Access at http://localhost:3000

TESTING:
- Unit tests for models
- Integration tests for routes
- Use cargo test

DEPLOYMENT:
- Production uses environment variables
- Secrets in .env file (never commit)
- Health checks at /health

================================================================================
KEY COMMANDS
================================================================================

# Start services
docker-compose up -d

# Run development server
cargo run

# Run with hot reload
cargo watch -x run

# Run tests
cargo test

# Format code
cargo fmt

# Lint code
cargo clippy

================================================================================
TEMPLATE IMPLEMENTATION CHECKLIST
================================================================================

When creating or updating templates, ensure:

STRUCTURE:
- Every major section has a unique ID
- All form inputs have associated labels via ID
- Error messages are linked to inputs via aria-describedby
- Major components use data-component attribute
- Page context is set with data-page on body
- Sections use data-section for context

NAVIGATION:
- Current page uses aria-current="page"
- Navigation sections have aria-label
- Skip links are provided for keyboard navigation
- Dropdown menus use details/summary or proper ARIA

FORMS:
- Each form has a unique ID
- All inputs have unique IDs
- Labels are properly associated with inputs
- Error messages have role="alert"
- Required fields are marked with required attribute
- Invalid fields use aria-invalid
- Help text is linked via aria-describedby

INTERACTIVE ELEMENTS:
- Buttons specify type attribute
- Toggle buttons use aria-pressed
- Expandable sections use aria-expanded
- Loading states are indicated with data-state
- Modals use dialog element or proper ARIA

CONTENT:
- Headings follow proper hierarchy
- Lists use appropriate ul/ol/dl elements
- Time elements use datetime attribute
- Images have alt text
- Links to external sites use rel="noopener"

================================================================================
WHEN IMPLEMENTING FEATURES
================================================================================

1. ALWAYS start with the model if database is involved
2. Create routes that use the models
3. Build templates that routes render
4. Add CSS using data attribute selectors
5. Test the complete flow
6. Handle errors gracefully

REMEMBER:
- Models access database ONLY
- Routes orchestrate and handle HTTP
- Templates render HTML
- Services handle business logic
- Middleware handles cross-cutting concerns
- NO JavaScript frameworks
- NO CSS classes for styling
- Server-side rendering ONLY

================================================================================
RED FLAGS TO AVOID
================================================================================

CLASS-BASED STYLING (FORBIDDEN):
- class="error", class="success", class="warning"
- class="button primary", class="btn-large"
- class="card", class="modal", class="dropdown"
- Any Bootstrap, Tailwind, or other CSS framework classes

INLINE STYLES (FORBIDDEN):
- style="color: red"
- style="display: none"
- Any style attribute

MISSING STRUCTURE (MUST FIX):
- Forms without IDs
- Inputs without IDs
- Labels without for attributes
- Missing aria-describedby for error messages
- Components without data-component
- Pages without data-page on body

SEMANTIC MISUSE (MUST FIX):
- Using <article> for forms, footers, or UI components
- Using <section> without headings
- Missing semantic HTML5 elements where appropriate
- Using divs when semantic elements exist

POOR NAMING (MUST FIX):
- Generic IDs like id="1", id="div1"
- Inconsistent naming patterns
- Missing data attributes for state
- No data-type for variations

================================================================================
AI TOOL INSTRUCTIONS
================================================================================

When asked to modify or create templates:

1. ALWAYS follow the ID naming convention: [context]-[element]-[purpose]
2. ALWAYS use data-component for major reusable components
3. ALWAYS use data-state for stateful elements
4. ALWAYS use data-type for variations
5. ALWAYS use data-page on body element
6. ALWAYS provide proper ARIA attributes
7. NEVER add CSS classes for styling
8. NEVER use inline styles
9. NEVER create non-semantic wrapper divs
10. ALWAYS ensure forms have proper ID associations

When working on the project in general:

11. DO NOT CREATE TEST SCRIPTS
    - Do not create shell scripts (.sh files) for testing functionality
    - Do not create test automation scripts
    - Testing should be done through Rust's built-in testing framework (cargo test)
    - If testing instructions are needed, provide them as comments in code or simple command examples

12. DO NOT ADD MIGRATION DOCS TO /docs
    - Do not create migration documentation in the /docs folder
    - Do not create update guides or changelog files in /docs
    - The /docs folder should only contain architectural and API documentation
    - Migration scripts belong in /scripts folder as SQL files only

13. PREFERRED APPROACHES
    - When fixing bugs: Provide code fixes directly with brief explanations as code comments
    - When adding features: Follow MVC pattern, update schema.surql directly (no migration files)
    - When documenting: Add technical docs to /docs only for architecture, include usage examples in code comments

================================================================================
END OF CONTEXT
================================================================================
